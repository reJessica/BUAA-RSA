# BUAA-RSA
 北航网络空间安全学院信息安全数学基础（信安数基）大作业

# RSA实现

## 必做1

### 实验原理

RSA算法的原理如下：

1. 选择两个大素数p和q，并计算N = p * q。
2. 计算欧拉函数phi = (p-1) * (q-1)。
3. 选择一个整数e，使得1 < e < φ(N)且（e，phi）=1，e为公钥指数。
4. 计算e的模反元素d，即d满足 d * e ≡ 1 (mod phi)，d为私钥指数。
5. 公钥为(N, e)，私钥为(N, d)。
6. 加密时，将明文m通过公式 c = m^e (mod N) 进行加密，得到密文c。
7. 解密时，将密文c通过公式 m = c^d (mod N) 进行解密，得到明文m。

RSA公钥密码体系的实现方案：

1. 确定合适的密钥长度。
2. 生成两个大素数p和q，并计算N = p * q。
3. 计算欧拉函数phi= (p-1) * (q-1)。
4. 选择公钥指数e。
5. 计算e的模反元素d。
6. 公钥为(N, e)，私钥为(N, d)。
7. 对需要加密的数据使用公钥进行加密，得到密文。
8. 使用私钥对密文进行解密，得到原始数据。

RSA算法的加速原理：

1. 中国剩余定理将解密过程分解为两个大素数模的计算，降低了计算的规模。
2. 使用快速模幂算法加速加密和解密过程中的指数运算，能减少做乘法的次数。

### 实验截图

![image-20231104122955781](C:/Users/21936/AppData/Roaming/Typora/typora-user-images/image-20231104122955781.png)

### 实验代码

```
import random


# 扩展欧几里得算法
def xgcd(a, b):
    if a % b == 0:
        return b
    else:
        c = a % b
        return xgcd(b, c)


# 求逆元算法
def inverse(m, N1, x1, y1, x2, y2):
    if m % N1 == 0:
        return x2
    else:
        (c, x3, y3) = ((m % N1), (x1 - (m // N1) * x2), (y1 - (m // N1) * y2))
        (m, x1, y1) = (N1, x2, y2)
        (N1, x2, y2) = (c, x3, y3)
        return inverse(m, N1, x1, y1, x2, y2)


# 快速模幂算法
def quickmod(m, e1, N2):
    list2 = [0] * len(bin(e1)[2:])
    temp = m
    re = 1
    for i in range(len(bin(e1)[2:])):
        list2[i] = temp
        temp = (temp * temp) % N2
    temp = e1
    for i in range(len(bin(e1)[2:])):
        if ((temp & 1) | 0) == 1:
            re = (re * list2[i]) % N2
        temp = temp >> 1
    return re


# 素性检验算法
def is_prime(n, times=5):
    if n <= 1:
        return False
    if n <= 3:
        return True
    k, q2 = 0, n - 1
    while q2 % 2 == 0:
        k += 1
        q2 = q2 // 2
    for i in range(times):
        a = random.randint(2, n - 2)
        x = quickmod(a, q2, n)
        if x == 1 or x == - 1 + n:
            continue
        for j in range(k - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False  # 寻找失败，则a为合数的米勒拉宾算证据 有一个就行
    return True  # 十个a都不为合数的米勒拉宾算证据


# 密钥生成函数
def getkey(bits):
    p2 = generate_prime(bits)
    q2 = generate_prime(bits)
    N3 = p2 * q2
    phi = (p2 - 1) * (q2 - 1)
    while True:
        e3 = random.randint(3, 100)
        if xgcd(e3, phi) == 1:
            break
    d3 = inverse(e3, phi, 1, 0, 0, 1)
    return N3, e3, d3, p2, q2


def generate_prime(bytes):
    while True:
        p1 = int.from_bytes(random.randbytes(bytes))
        if is_prime(p1):
            return p1


# 加解密函数
def solve(p4, q4, c, e4):
    N4 = p4 * q4
    phi = (p4 - 1) * (q4 - 1)
    d4 = (inverse(e4, phi, 1, 0, 0, 1) + phi) % phi
    flag1 = quickmod(c, d4, N4)
    return flag1


# 用中国剩余定理优化 RSA 的解密速度。
def CRT(c, p5, q5, e):
    d1 = (inverse(e, p5 - 1, 1, 0, 0, 1)+p5-1)%(p5-1)
    d2 = (inverse(e, q5 - 1, 1, 0, 0, 1)+q5-1)%(q5-1)
    red1 = (inverse(q5, p5, 1, 0, 0, 1)+p5)%p5
    red2 = (inverse(p5, q5, 1, 0, 0, 1)+q5)%q5
    return (q5 * red1 * quickmod(c, d1, p) + p5 * red2 * quickmod(c, d2, q)+p5*q5)%(p5*q5)


# 扩展要求a. 对消息进行数字编码，进而实现对消息进行加解密。
def s2n(msg2):
    encoded_msg = ""
    for char in msg2:
        ascii_val = str(ord(char))
        encoded_msg += ascii_val
    return int(encoded_msg)


def n2s(msg3):
    decoded_msg = ""
    i = 0
    while i < len(msg3):
        ascii_val = int(msg3[i:i + 3])
        if 128 > ascii_val > 99:
            decoded_msg += chr(ascii_val)
            i += 3
            continue
        else:
            ascii_val = int(msg3[i:i + 2])
            if 100 > ascii_val > 10:
                decoded_msg += chr(ascii_val)
                i += 2
                continue
            else:
                ascii_val = int(msg3[i:i + 1])
                decoded_msg += chr(ascii_val)
                i += 1
                continue
    return decoded_msg


# 加解密函数
msg = input()  # 输入要加密的明文
N, e, d, p, q = getkey(128)  # 得到密钥
msg = s2n(msg)  # 对消息进行数字编码，进而实现对消息进行加密
print(msg)  # 打印密文
# 普通求解
c1 = quickmod(msg, e, N)
flag = solve(p, q, c1, e)
flag = n2s(str(flag))
print(flag)
# 使用CRT算法进行加速求解
flag = CRT(c1, p, q, e)
flag = n2s(str(flag))
print(flag)

```



### 思考题

在完成大作业的过程中，我也了解到了多种RSA的攻击方法，这些攻击都利用泄露了的部分信息以及公钥的某些特点，这也给我们警示

1.在选择p，q时要注意以下的几个方面：

+ p.q的选择相差要大。若相差较小(（p+q)/2)^2^=N+((p-q)2)^2^,易直接开方解得p+q

+ p-1，q-1的最大公因子要满足较小，由de=1（mod （p-1）*(q-1)/(p-1,q-1)),若公因子较大，则模数会相应减小，容易被暴力攻破

2.同时，在密钥的选择上：

+ RSA算法的安全性依赖于大素数的难以分解性质。因此，在选择素数时应该选择足够大的素数，密钥长度越长，算法的安全性就越高，但加解密的速度就越慢，故而我们应当在这两者之间寻找一个平衡。

3.对于可能存在的共模攻击，我们故而得知：

+ 模数 n 不能共用或者复用

4.公钥指数e的选择上

+ 应该选择一个较大的素数，通常为65537（2^16^+1)。但实际上e=3与e=65537同样安全

5.在解密指数上：

+ 若d<N^1/4^,则可以采取连分式理论破解RSA，故而我们要注意避免解密指数d过小

# RSA攻击

## leve1

### 实验原理

根据题目描述，我们需要对给定的加密文本进行解密。

可以容易看到，此次加密使用了两组（e1，N），（e2，N）密匙对同一个明文进行加密，故而我们采取共模攻击的方法

原理如下：

易知（e1，e2）=1；

c1=flag^e1^(mod N);

c2=flag^e2^(mod N);

使用xgcd可以利用扩展欧几里得算法求得u * e1+v * e2=gcd(e1, e2)=1的系数u，v；

使用pow函数，求得m1=c1^u^(mod N) m2=c2^v^(mod N)

故而易得 flag=m1 * m2=c1^u^*c2^v^=flag^ue1^*flag^ve2^=flag^ue1+ve2^=flag(mod N)

### 实验截图

![](C:/Users/21936/AppData/Roaming/Typora/typora-user-images/image-20231101180422463.png)

### 实验代码

```
from AITMCLAB.libnum import n2s, xgcd

e1 = 65537
e2 = 963419
N = 22535333632400611169819641917374984574413556781780462495538364642625621812345616195370415361162281672714531244185605075004898223796730121356666857286221985295140581783736166611979560499195582810474395857149764536637053225340336708048306808297924665454348513460424053101087340675488225292806177969636009488978215879489679576737023269428674010221359741128731223162151060832780527281594350783847429988090447402175764667566870717825851295876599669130316453340765093368864653164900249432838111418197691501422846653920724316459901075273414847550384083382634986883106993145856517020790033544105218669199809066158299261480367

c1 = 18695447919164512742520026092358152016777602292803823318467479903184451503670054765252728353586268860249186095879076233729591697489038459368938872137068190078179129791580197846496906213031081980307264347701247257778029176954105577449459502856332421302782832341006567687493175191666698403772215611134168840495434563849566068964426236599677174374333169544431957766419895045704321941014199369146756446831849777814088335160074869919505279257760144032597907580769370658423645741446106592468131725551657127204364547101840201069729639775026507003077137222596196395683396793914686489117708083004608495698827253322237966726010
c2 = 4511544261239703717698533123913468133807740632075321833215456540023044278844406156407244027454133343514264016198589312559429726083069074153267055496981918112774595630272424954528137036153203974994500742442125567759539112322544029483665905155341171833208498869184858836364033975788256491785058225088568581953905691481951290994196540491263382433016941911088553181103003993285565163060269372569090186604590594289510074442971114084069249201742523973988637718710747546828109234756617292083291134231538099763874061984792852486785270790009514231665301348769279902529006193365378169064082259262277490468774339755421277727897

u, v, gcd = xgcd(e1, e2)
m1 = pow(c1, u, N)
m2 = pow(c2, v, N)
M = (m1 * m2) % N
flag = n2s(M)
print(flag)
```

### 安全分析

产生安全问题的原因在于

+ 由于相同的模数被两个密匙（e1，N），（e2，N）对同一个密文进行加密使用，导致攻击者可以通过观察加密结果的共同特征来获取私钥信息。
+ 这可能是由于生成密钥时未使用足够随机的方法，或者由于错误地复用了已有的模数。

故而我们在加密时应当避免使用不同的e指数和相同的N进行加密。  

## leve2

### 实验原理

此攻击分为两部分

对后半部分：

由输出，已知c，d；

由已知 d = invmod(e, phi)，即ed=1（mod phi）

由c = pow(msg, e, N)，即c=msg^e^(mod N);

故易知c^d^=msg^ed^=msg^1^=msg(mod N);

故采用msg=pow（c，d，N）求得后半部分的明文（采取n2s进行转换）

对前半部分：

关键在于在已知N和后半部分的一组（c，d）的基础上分解N得到p，q；

定义def函数对其进行分解，原理如下：

由ed=1（mod phi），可得ed-1=r*phi；

令k=ed-1，即然后选择一个随机数 m，满足 1<g<N 。

即m^k^=1(mod N)

将k进行二进制分解，得到k = 2^t * r，可分解至（m^k/2^+1)(m^k/4^+1)……(m^k/2^^^i^–1)=0(mod N)

接下来，通过多次尝试不同的m值，计算temp = （m^k mod N） - 1，然后计算gcd(temp, n)。当发现m^k/2^^^i^–1与N互素时，即可得其为p；如果这样的 P不存在，就重新生成随机数 m重新尝试分解 。

N整除p得到q；

由求得的p，q得到phi=（p-1）*（q-1）

由d2 = invmod(e2, phi)求得逆元

此后步骤重复对后半部分的攻击，得到flag



### 实验截图

![image-20231101182139623](C:/Users/21936/AppData/Roaming/Typora/typora-user-images/image-20231101182139623.png)

### 实验代码

```
import binascii

from gmpy2 import gmpy2

from AITMCLAB.libnum import n2s, invmod
from Crypto.Random import random


def getpq(n, e, d):
    while True:
        k = e * d - 1
        g = random.randint(0, n)
        while k % 2 == 0:
            k = k // 2
            temp = gmpy2.powmod(g, k, n) - 1
            if gmpy2.gcd(temp, n) > 1 and temp != 0:
                return gmpy2.gcd(temp, n)


e2 = "0x20211011"
N = 13060606190646199509417869356893267164607938890520467870153612362923013181328713588734302032470871311119075018295743512432062027679699631486289048751940000390702928313128503683763312047588132600893624316613364968822882615394231293334096920586472306218844512060241241481071962559819156475871222605349887836439374595154871602789016066314352344801679678904320232245670077498309355518716202967364998882174699874635510699778392294962945740361706295834051212767581306434391702148346687634020223987189945847373798131306738716742431780536902027877938213541406416671341664326108536986035396556510051111175698573222348057823413
c = 12867372944375883854363336601880441267261705355537611760294299925805251244958240103275237526767967626730074533544706890152570845224299535823447617779959842661570202936662285154578650228980267458478400193880058527910444648593865055027425009398697715988558697215651204631228634120733447428080516613329058531236663341873013234313135976077554334823422466390163254186997490374590109457849311320742584122358371540895634091966591313413497495482065372727880557421434854495173567124523314584947473382926561943980624934914344101538583686153455093983696176534133992069883954123992059741137121203135256339471481299934993685690535
d = 9969657475998937469021465897161826708623848962701092023394784614730559602493770413573679466781102793745088550068463791427229873047301230783533330171649341852206511285454324446046951438301189101085097334718684813402290643815428591069394835359542986636301905444528572731817493783982522608575126245027219632378068945474676583057371930180586121841758249731437689732342352462199610389756420475424547263696944976526413386592689716075191720833223945876263580920598686018269885511355644771607916907644920921567133184039090637039399962053936720420717689164266788961705574424755953725616929893071733963534429106859309620585059
e = 15914069303469478985296031900096138686210691626298764671051513402315652347029310520321090661658475897916286419500322704067930668674914412307883782100648403045900183352937563718396725611487763139463550781345793379247065512809728533907031510876312340707456265195686508575669272358507805985809090526914742692976143110492662643061134152956918280648407073577994882755603040531527515069730183439937103163430813463617785925355580832784868432411925033506675117979373574755395089454602586924007062714815737517183001493233808535379400645074622299415897855024755149948418395437703490238468629392113068726513662136683200855626539
c2 = 9653438417109781006180300105965030770533923108438573417035236405223006643830833836848930593198565118145943104129405986622459386109109443225936482662709179567452692134122646722289469049850498371300719126764728901995261968830119093181464029349462835381381057841639247554016659408237757931516614410756700681681612363113386068247795154628119640820304439170561100229519496966306654942224840050178760290299291423392147951419027305446084327522074490702264790829918437889096135198899247119727418336608309180045229236116749597930330615358311162208113123716881427509985361593743207052472174899037471834858024035722508078491025

e2 = int(e2, 16)
q = getpq(N, e, d)
p = N // q
phi = (p-1) * (q-1)
d2 = invmod(e2, phi)
flag = gmpy2.powmod(c2, d2, N)
flag = n2s(int(flag))
print(flag)
msg = pow(c, d, N)
msg = n2s(msg)
print(msg)

```



### 安全分析

产生安全问题的原因在于

+ 由于已知一组由phi求得逆元d的易解密组，可得到ed-1=r*phi，利用了e * d - 1是p和q的倍数的特性
+ 在已知一组（e，d）上，，计算k = e * d - 1，容易通过随机选择一个整数g，将k进行二进制分解，得到k = 2^t * r，其中r是一个奇数，

故而我们在加密时应当避免使用不同的e指数和相同的N进行加密，对解密指数的情况要保密好。  

## level3

### 实验原理

**RSA低解密指数解密攻击：**
  已知N，e，c，由题目可知d = randint(0, int((N ** 0.25) // 3))，则考虑使用低解密指数解密攻击

由ed=1（mod phi），可得ed-1=r*phi；对式子进行处理，两边同时除以d和phi

即e/phi -r/d = 1/(d*phi)

由N很大，1/d*phi趋近于0，而N约等于phi，

所以可近似认为e/N=r/d (e/n略大于k/d)  

通过对e/n进行连分数展开，依次求其渐进分数，因为e/N > r/d 所以e/N 的渐进分数一定覆盖r/d。



遍历所有渐进分数如果找到了d的话，(e*d-1)会整除phi,也就是存在k使得(e*d-1)//k=phi,建立方程求p,q。（ x2−(p+q)∗x+pq=0这个方程的解就是p,q）如果p*q==n则找到了d

通过遍历r/d，对于满足 (e * d - 1) % r == 0的情况，可得phi = (e * d - 1) // r

通过phi=(p-1)*(q-1)=p*q-(p+q)+1=N-(p+q)+1得到（p+q）=N+1-phi，

x^2^−(p+q)∗x+pq=x^2^−(N+1-phi)∗x+N=（x-p）*（x-q）

求解得到的p，q

检验p*q是否等于N，若满足条件，则输出p，q

进而继续对p，q，得到phi=（p-1)*(q-1)

求得解密指数d，进而flag = gmpy2.powmod(c, d, N)，得到flag

### 实验截图

![image-20231103170805559](C:/Users/21936/AppData/Roaming/Typora/typora-user-images/image-20231103170805559.png)

### 实验代码

```
import gmpy2

from AITMCLAB.libnum import n2s

def t_cf(n, d2):  # 将分数 x/y 转为连分数的形式
    res = []
    while d2:
        res.append(n // d2)
        n, d2 = d2, n % d2
    return res


def cf(sub_res):  # 得到渐进分数的分母和分子
    n, d1 = 1, 0
    for i in sub_res[::-1]:  # 从后面往前循环
        d1, n = n, i * n + d1
    return d1, n


def list_fraction(x, y):  # 列出每个渐进分数
    res = t_cf(x, y)
    res = list(map(cf, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def wienerAttack(e, n):
    for (d, r) in list_fraction(e, n):  
        if r == 0:  
            continue
        if (e * d - 1) % r != 0: 
            continue
        phi = (e * d - 1) // r
        par = gmpy2.isqrt((n - phi + 1) * (n - phi + 1) - 4 * n) 
        P, Q = (phi - n - 1 + par) // 2, ((phi - n - 1) - par) // 2
        if P * Q == n:
            return P, Q

N = 22237835302922059976809402067504825338639397613428644716911013462933987010320338197027313870904884600832274127599253164756052947120471407072747145133107161086963773155481771933890075746323950034306108053494905455035836092419392902164790046123870425239069335460143733318939720277362543432823660639552749610593953815168481144428687024963321170195850066773988712306169387188341439198060130573611408506007379968291269958439926326037202978272704730296953420402849276339211848007387020337017062668054847344394988543474345927596814866280441723537511247164610232659105337995277883267360793352790905118017002541173761431075999
e = 2840775010818853892218878969282454736342242025233130737815807177792231399640174225515967150768448132981677608457043824160319825478091843128389115590651415338211628268581833842723762368692094475826552798676670248518559214358011861408120621001645040773382200363058370769116466643973059653094324346908331307121763112569854699547686147856752189181950330442647749285684040937861337493550456323749318297556889992038072224857538282695142448000570443956526947434387423525745612850268643092758064963492260234850189691261491612271750333260596819402647180890667688637170670535382923020907626591863620731348799551457399710470661
c = 5552091951745782262963697032938934308567074561404006576640800210831085363563365571354071571660814176629772213215122766813707090875146292255127349015561894570380567729168703778355674207420850183516449966228728693019116160369690168134150112462837154696331037215148327748410520558556175540944523891360966118008025750075121576950576438362520358455406637580928744576440372283329101865316335401677703810423117561936029083442060784631681515616713870241972476974825487103816409681391515999981670378727290127882730006335791627845283887269182415677716621425592222466939349695789128380671373520371522016390854591573254475388862

d = wienerAttack(e, N)   #通过连分式理论求d
flag = gmpy2.powmod(c, d, N)
flag = n2s(int(flag))
print(flag)
```



### 安全分析

产生安全问题的原因在于

+ 选择的解密指数较小，导致加密数据被破解或者被攻击者获得私钥从而篡改数据。

故而我们在加密时应当避免选择较小的解密指数，同时对解密指数的情况要保密好。  
