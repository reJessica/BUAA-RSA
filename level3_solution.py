import gmpy2

from AITMCLAB.libnum import n2s


# numerator(n):分子, denominator(d)：分母
def t_cf(n, d2):  # 将分数 x/y 转为连分数的形式
    res = []
    while d2:
        res.append(n // d2)
        n, d2 = d2, n % d2
    return res


def cf(sub_res):  # 得到渐进分数的分母和分子
    n, d1 = 1, 0
    for i in sub_res[::-1]:  # 从后面往前循环
        d1, n = n, i * n + d1
    return d1, n


def list_fraction(x, y):  # 列出每个渐进分数
    res = t_cf(x, y)
    res = list(map(cf, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def wienerAttack(e, n):
    for (d, r) in list_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if r == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % r != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue
        phi = (e * d - 1) // r
        par = gmpy2.isqrt((n - phi + 1) * (n - phi + 1) - 4 * n)  # 由上述可得，开根号一定是整数，因为有解
        P, Q = (phi - n - 1 + par) // 2, ((phi - n - 1) - par) // 2
        if P * Q == n:
            return P, Q
    print("求解d失败")


N = 22237835302922059976809402067504825338639397613428644716911013462933987010320338197027313870904884600832274127599253164756052947120471407072747145133107161086963773155481771933890075746323950034306108053494905455035836092419392902164790046123870425239069335460143733318939720277362543432823660639552749610593953815168481144428687024963321170195850066773988712306169387188341439198060130573611408506007379968291269958439926326037202978272704730296953420402849276339211848007387020337017062668054847344394988543474345927596814866280441723537511247164610232659105337995277883267360793352790905118017002541173761431075999
e = 2840775010818853892218878969282454736342242025233130737815807177792231399640174225515967150768448132981677608457043824160319825478091843128389115590651415338211628268581833842723762368692094475826552798676670248518559214358011861408120621001645040773382200363058370769116466643973059653094324346908331307121763112569854699547686147856752189181950330442647749285684040937861337493550456323749318297556889992038072224857538282695142448000570443956526947434387423525745612850268643092758064963492260234850189691261491612271750333260596819402647180890667688637170670535382923020907626591863620731348799551457399710470661
c = 5552091951745782262963697032938934308567074561404006576640800210831085363563365571354071571660814176629772213215122766813707090875146292255127349015561894570380567729168703778355674207420850183516449966228728693019116160369690168134150112462837154696331037215148327748410520558556175540944523891360966118008025750075121576950576438362520358455406637580928744576440372283329101865316335401677703810423117561936029083442060784631681515616713870241972476974825487103816409681391515999981670378727290127882730006335791627845283887269182415677716621425592222466939349695789128380671373520371522016390854591573254475388862

(p, q) = wienerAttack(e, N)
d = gmpy2.invert(e, (abs(int(p)) - 1) * (abs(int(q)) - 1))  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
flag = gmpy2.powmod(c, d, N)
flag = n2s(int(flag))
print(flag)
